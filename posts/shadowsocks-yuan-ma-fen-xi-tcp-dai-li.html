<!Doctype html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<meta name="renderer" content="webkit">
<meta name="HandheldFriendly" content="True">
<meta name="google-site-verification" content="xRiYQAQ0h0n3RXqrq0GgrdFm3BMFqDvDwwiRylv0YhQ">

<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">
<meta name="author" content="loggerhead" />    <meta name="keywords" content="源码分析,Python" />

  <meta name="description" content="Shadowsocks 源码分析——协议与结构 已经对 shadowsocks 进行了大体上的分析，我们进一步的深入，来了解 shadowsocks 真正的核心——TCP 代理。" />

  <title>  Shadowsocks 源码分析——TCP 代理
</title>

<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">

  <link rel="stylesheet" href="https://loggerhead.me/theme/css/style.5a21e2a.css">
 
  <link rel="icon" type="image/x-icon" href="/favicon.ico">

  <link href="https://loggerhead.me/atom.xml" rel="alternate" type="application/atom+xml">
</head>
<body>

<nav class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://loggerhead.me">loggerhead's blog</a>
    </div>
    <div class="navbar-collapse navbar-ex1-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
          <a href="https://loggerhead.me/index.html">首页</a>
        </li>
        <li>
          <a href="https://loggerhead.me/archives.html">归档</a>
        </li>
        <li>
          <a href="https://loggerhead.me/about.html">关于</a>
        </li>
      </ul>
      <div class="navbar-right">
        <ul class="nav navbar-nav">
          <form class="navbar-form" role="search" action="https://www.google.com" target="_blank">
    <div class="input-group">
        <input type="text" class="search-query form-control" placeholder="搜索博客" name="q">
        <input type="hidden" name="cx" value="005992921674098475959:hyjwdbdoqt8">
        <input type="hidden" name="ie" value="UTF-8">
        <span class="input-group-btn">
            <button class="btn btn-default" type="submit">
                <span class="glyphicon glyphicon-search"></span>
            </button>
        </span>
    </div>
</form>
        </ul>
        <ul class="nav navbar-nav">
          <li><a href="https://github.com/loggerhead" target="_blank">GitHub</a></li>
          <li><a href="https://keybase.io/loggerhead" target="_blank">Keybase</a></li>
          <li><a href="https://douban.com/people/loggerhead" target="_blank">豆瓣</a></li>
        </ul>
      </div>
    </div><!--/.navbar-header -->
  </div><!--/.container -->
</nav><!--/.navbar -->

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="markdown-body article-list">
  <section id="content">
    <article>
      <header class="page-header">
        <h1>
          <a class="article-title" href="https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-tcp-dai-li.html" rel="bookmark" title="Permalink to Shadowsocks 源码分析——TCP 代理">
            Shadowsocks 源码分析——TCP 代理
          </a>
        </h1>
<footer class="post-info">
  <div class="row">
    <div class="col-xs-8">
      <!-- <span class="label label-default">Tags</span> -->
        <a class="tag btn btn-xs" href="https://loggerhead.me/tag/yuan-ma-fen-xi.html">
          源码分析
        </a>
        <a class="tag btn btn-xs" href="https://loggerhead.me/tag/python.html">
          Python
        </a>
    </div>

    <div class="col-xs-4 time">
      <time class="pull-right" datetime="2017-01-04T10:40:00+08:00">
        2017-01-04
      </time>
    </div>
  </div>
</footer>        <hr>
      </header>
      <div class="entry-content">
        <p><a href="/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html">Shadowsocks 源码分析——协议与结构</a> 已经对 shadowsocks 进行了大体上的分析，我们进一步的深入，来了解 shadowsocks 真正的核心——TCP 代理。</p>


<div class="toc">
<ul>
<li><a href="#tcprelay">TCPRelay</a></li>
<li><a href="#tcprelayhandler">TCPRelayHandler</a><ul>
<li><a href="#_1">命名约定</a></li>
<li><a href="#_on_local_read">_on_local_read 函数</a></li>
<li><a href="#_on_local_xxx-_on_remote_xxx">_on_local_XXX / _on_remote_XXX 函数</a></li>
<li><a href="#_handle_xxx">_handle_XXX 函数</a><ul>
<li><a href="#_handle_stage_init">_handle_stage_init</a></li>
<li><a href="#_handle_stage_addr">_handle_stage_addr</a></li>
<li><a href="#_handle_dns_resolved">_handle_dns_resolved</a></li>
<li><a href="#_handle_stage_connecting">_handle_stage_connecting</a></li>
<li><a href="#_handle_stage_stream">_handle_stage_stream</a></li>
</ul>
</li>
<li><a href="#_2">事件与状态</a><ul>
<li><a href="#_update_stream">_update_stream</a></li>
<li><a href="#_on_remote_read">_on_remote_read</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_3">总结</a></li>
</ul>
</div>
<h1 id="tcprelay">TCPRelay</h1>
<p><a href="/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html#eventlooppy">前文</a>已经说过了，shadowsocks 是一个反应器模式，它会在 eventloop 中将事件一层一层的传递给真正的处理者。</p>
<p><img alt="reactor" src="https://cdn.loggerhead.me/images/ss-reactor-pattern.png" /></p>
<p>和 TCP 相关的任何事件，首先会经过 <code>TCPRelay</code> 之手，根据事件对应的套接字执行不同的逻辑，具体的代码是（删除了部分日志相关的代码）：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
    <span class="c1"># 如果是 TCPRelay 的 socket</span>
    <span class="k">if</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_server_socket</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_ERR</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;server_socket error&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="n">TCPRelayHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_to_handlers</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_eventloop</span><span class="p">,</span> <span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_dns_resolver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error_no</span> <span class="o">=</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">error_no</span> <span class="ow">in</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINPROGRESS</span><span class="p">,</span>
                            <span class="n">errno</span><span class="o">.</span><span class="n">EWOULDBLOCK</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shell</span><span class="o">.</span><span class="n">print_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
    <span class="c1"># 如果是 TCPRelayHandler 的 socket</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sock</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_to_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">handler</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">handle_event</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;poll removed fd&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>如果发生事件的套接字是 <code>TCPRelay</code> 它自己的，那么 <code>accept()</code> 建立一个新的 TCP 连接，并且创建一个 <code>TCPRelayHandler</code> 对象来负责处理它；否则，说明发生事件的套接字是 <code>TCPRelayHandler</code> 的，此时根据 <code>fd</code> 找到对应的 <code>handler</code>，并调用它的 <code>handle_event</code> 来处理事件。</p>
<p>注意到调用 <code>accept()</code> 之前没有对事件类型进行判断，说明这个 <code>event</code> 一定是 <code>eventloop.POLL_IN</code>。我们看到 <code>add_to_loop</code> 这个函数：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_to_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eventloop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;already add to loop&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;already closed&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_eventloop</span> <span class="o">=</span> <span class="n">loop</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_eventloop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_server_socket</span><span class="p">,</span>
                        <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_IN</span> <span class="o">|</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_ERR</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_eventloop</span><span class="o">.</span><span class="n">add_periodic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle_periodic</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>确实只注册了读事件，证实了我们的猜想。再回头看看 <code>TCPRelay</code> 的初始化：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">addrs</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">listen_addr</span><span class="p">,</span> <span class="n">listen_port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOL_TCP</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">addrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
  <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;can&#39;t get addrinfo for </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">listen_addr</span><span class="p">,</span> <span class="n">listen_port</span><span class="p">))</span>
<span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">_server_socket</span> <span class="o">=</span> <span class="n">server_socket</span>
</pre></div>
</td></tr></table>

<p>上面是 <code>__init__</code> 函数的部分代码。可以看到第 1 行调用了会阻塞的函数 <code>getaddrinfo</code> 进行地址解析<sup id="fnref:getaddrinfo"><a class="footnote-ref" href="#fn:getaddrinfo" rel="footnote">1</a></sup>。比如：它能将 <code>localhost.loggerhead.me</code> 或 <code>localhost</code> 解析成 <code>127.0.0.1</code>，这也是为什么 shadowsocks 的服务器地址可以填域名的原因。可以看出 <code>self._server_socket</code> 是一个典型的 TCP 服务器套接字，说明 <code>TCPRelay</code> 只是个普通的 TCP 服务器，只不过兼任了转发事件的功能。</p>
<p>其它的函数，诸如：<code>update_activity</code>、<code>handle_periodic</code> 等，都是用来处理超时的，本文暂且不提。</p>
<h1 id="tcprelayhandler">TCPRelayHandler</h1>
<p>在事件经由 <code>TCPRelay</code> 转发给 <code>TCPRelayHandler</code> 以后，<code>handle_event</code> 会负责处理这个事件。它会进一步根据事件的种类，调用相应的函数进一步处理，某种意义上来说也是转发。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_DESTROYED</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;ignore handle_event: destroyed&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_sock</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">elif</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_ERR</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_local_error</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_DESTROYED</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_IN</span> <span class="o">|</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_HUP</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_local_read</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_DESTROYED</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">&amp;</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_OUT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_local_write</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;unknown socket&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><code>handle_event</code> 会根据事件发生的套接字决定调用的函数，这里涉及到 <code>self._remote_sock</code> 和 <code>self._local_sock</code> 两个套接字，它俩在很多方面都是对称、相似的，比如：<code>if</code> 代码块与 <code>elif</code> 代码块中的代码是一模一样的，只是 <code>remote</code> 换成了 <code>local</code>，所以这里省略了。那么这两个套接字有什么用呢？此处出现的 <code>self._stage</code> 又是干什么的？为了解答这两个问题，我们得先介绍几个概念。</p>
<h2 id="_1">命名约定</h2>
<p>每一个 TCP 连接，都由一个 <code>TCPRelayHandler</code> 处理，而每一个 <code>TCPRelayHandler</code> 又都有两个套接字。</p>
<p><img alt="ss-socks" src="https://cdn.loggerhead.me/images/ss-socks.png" /></p>
<p>如图所示，黄色圆点表示 <code>local_sock</code>，绿色圆点表示 <code>remote_sock</code>。</p>
<ul>
<li>对于 <code>sslocal</code> 而言，<code>local</code> 指 SOCKS5 客户端，<code>remote</code> 指 <code>ssserver</code>；</li>
<li>对于 <code>ssserver</code> 而言，<code>local</code> 指 <code>sslocal</code>，<code>remote</code> 指目标服务器；</li>
</ul>
<p>所以 <code>local_sock</code> 就是专门负责与左边通信的套接字，<code>remote_sock</code> 是专门负责与右边通信的套接字。另外，需要注意的是因为 shadowsocks 客户端和服务器重用了绝大部分的代码，所以在判断当前程序是当做 <code>sslocal</code> 还是 <code>ssserver</code> 用时会用一个变量 <code>is_local</code> 来判断，这里的 <code>local</code> 指的是 <code>sslocal</code>。</p>
<p>为了区分，「客户端」指 <code>sslocal</code> 左边的 SOCKS5 客户端，「ss 客户端」指 <code>sslocal</code>。</p>
<h2 id="_on_local_read">_on_local_read 函数</h2>
<p>上面提到 <code>handle_event</code> 函数，我们注意到当发生事件的套接字是 <code>local_sock</code> 时，只涉及到三个函数，分别对应于几种事件：</p>
<ul>
<li><code>OLL_ERR</code>: <code>self._on_local_error()</code></li>
<li><code>OLL_IN</code> 或 <code>POLL_HUP</code>: <code>self._on_local_read()</code></li>
<li><code>OLL_OUT</code>: <code>self._on_local_write()</code></li>
</ul>
<p>其中 <code>eventloop.POLL_HUP</code> 事件发生说明套接字关闭了。我们进一步的分析 <code>_on_local_read</code> 函数：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_on_local_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="c1"># 防御性编程，完全是多余的</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="p">:</span>
       <span class="k">return</span>
   <span class="n">is_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span>
   <span class="c1"># 接受至多 BUF_SIZE 大小的数据，如果此时发生异常，那么分两种情况处理：</span>
   <span class="c1"># 1. 如果异常产生的原因是 `ETIMEDOUT`, `EAGAIN` 或 `EWOULDBLOCK` 则返回</span>
   <span class="c1"># 2. 否则直接销毁当前的 TCPRelayHandler</span>
   <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
   <span class="k">try</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">)</span>
   <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
       <span class="k">if</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> \
               <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">ETIMEDOUT</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EWOULDBLOCK</span><span class="p">):</span>
           <span class="k">return</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
       <span class="k">return</span>

   <span class="c1"># 重置计时器</span>
   <span class="bp">self</span><span class="o">.</span><span class="n">_update_activity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

   <span class="c1"># 如果 data 是 sslocal 发送过来的，则解密数据</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">is_local</span><span class="p">:</span>
       <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encryptor</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
           <span class="k">return</span>

   <span class="c1"># 典型的状态机，根据当前的状态执行相应的函数</span>
   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_STREAM</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_handle_stage_stream</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       <span class="k">return</span>
   <span class="k">elif</span> <span class="n">is_local</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_INIT</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_handle_stage_init</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_CONNECTING</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_handle_stage_connecting</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
   <span class="k">elif</span> <span class="p">(</span><span class="n">is_local</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_ADDR</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="ow">not</span> <span class="n">is_local</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_INIT</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_handle_stage_addr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><code>_on_local_read</code> 会从 <code>local_sock</code> 读数据，并根据状态，将数据交由不同的函数处理。<code>self._stage</code> 记录了对应的状态，它的取值如下：</p>
<ul>
<li><code>TAGE_INIT</code>: SOCKS5 的握手阶段，协商采用的认证方式；</li>
<li><code>TAGE_ADDR</code>：SOCKS5 建立连接阶段，对 <code>remote</code> 进行 DNS 查询；</li>
<li><code>TAGE_UDP_ASSOC</code>：与 UDP 代理相关；</li>
<li><code>TAGE_DNS</code>：正在进行 DNS 查询；</li>
<li><code>TAGE_CONNECTING</code>：正在建立 TCP 连接；</li>
<li><code>TAGE_STREAM</code>：SOCKS5 传输阶段；</li>
<li><code>TAGE_DESTROYED</code>：<code>TCPRelayHandler</code> 已经被销毁。</li>
</ul>
<p>我从 <code>_on_local_read</code> 的代码可以看出，只有四种状态对应了相关的执行函数：</p>
<ul>
<li><code>TAGE_INIT</code>: <code>self._handle_stage_init</code>；</li>
<li><code>TAGE_ADDR</code>：<code>self._handle_stage_addr</code>；</li>
<li><code>TAGE_CONNECTING</code>：<code>self._handle_stage_connecting</code>；</li>
<li><code>TAGE_STREAM</code>：<code>self._handle_stage_stream</code>。</li>
</ul>
<p>其的状态 <code>STAGE_UDP_ASSOC</code>、<code>STAGE_DNS</code>、<code>STAGE_DESTROYED</code> 都只是作为一个标记，并不导致状态改变。既然整个 <code>TCPRelayHandler</code> 是一个状态机，那么它的起始状态至关重要，我们到 <code>__init__</code> 函数中发现无论是 <code>sslocal</code> 还是 <code>ssserver</code>，起始状态都是 <code>STAGE_INIT</code>，但是注意到 <code>_on_local_read</code> 中的几行：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>   <span class="k">elif</span> <span class="p">(</span><span class="n">is_local</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_ADDR</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="ow">not</span> <span class="n">is_local</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">==</span> <span class="n">STAGE_INIT</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">_handle_stage_addr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>还记得<a href="/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html">前文</a>里有提过：</p>
<blockquote>
<p>可以看出来，SOCKS5 服务器的实现被拆分成了两部分：</p>
<ul>
<li>sslocal 负责与 SOCKS5 客户端进行 SOCKS5 协议相关的通讯（握手并建立连接），在建立连接后将 SOCKS5 客户端发来的数据加密并发送给 ssserver；</li>
<li>ssserver 起到一个中继的作用，负责解密以后将数据转发给目标服务器，并不涉及 SOCKS5 协议的任何一部分。</li>
</ul>
</blockquote>
<p>所以 <code>ssserver</code> 真正的起始状态是 <code>STAGE_ADDR</code> 而不是 <code>STAGE_INIT</code>，因为 <code>ssserver</code> 不负责 SOCKS5 的握手协商。整个状态的转移过程如下（省略了前缀 <code>STAGE_</code>，下文同）：</p>
<ul>
<li><code>slocal</code>: <code>INIT</code> -&gt; <code>ADDR</code> -&gt; <code>DNS</code> -&gt; <code>CONNECTING</code> -&gt; <code>STREAM</code> -&gt; <code>DESTROYED</code>；</li>
<li><code>sserver</code>: <code>ADDR</code> -&gt; <code>...</code>；</li>
</ul>
<p>总结一下，<code>_on_local_read</code> 函数会在 <code>self._local_sock</code> 可读时被 <code>_handle_event</code> 调用。它会根据当前的 <code>self._stage</code> 调用对应的函数处理读到的数据 <code>data</code>。</p>
<h2 id="_on_local_xxx-_on_remote_xxx">_on_local_XXX / _on_remote_XXX 函数</h2>
<p>除了 <code>_on_local_read</code> 与 <code>_on_remote_read</code> 以外，以 <code>_on</code> 开头的另外四个函数有着类似的结构和功能，它们都是在对应的套接字发生对应的事件时被 <code>_handle_event</code> 函数调用。其中函数与套接字的对应关系如下：</p>
<ul>
<li><code>on_local_XXX</code> 对应于 <code>self._local_sock</code>；</li>
<li><code>on_remote_XXX</code> 对应于 <code>self._remote_sock</code>；</li>
</ul>
<p><code>_on_local_XXX</code> / <code>_on_remote_XXX</code> 对应的事件，以及对应的功能如下表所示：</p>
<table>
<thead>
<tr>
<th>数名</th>
<th>事件</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rror</code></td>
<td><code>POLL_ERR</code></td>
<td>写日志并调用 <code>self.destroy</code> 进行销毁</td>
</tr>
<tr>
<td><code>rite</code></td>
<td><code>POLL_OUT</code></td>
<td>如果 <code>self._data_to_write_to_XXX</code> 有数据，则写入 <code>self._XXX_sock</code>；否则，更新套接字监听的事件</td>
</tr>
</tbody>
</table>
<p>这里大体的提一下，具体的细节我们稍后再看。</p>
<h2 id="_handle_xxx">_handle_XXX 函数</h2>
<p><code>_handle_XXX</code> 函数负责了 SOCKS5 协议的相关通讯，控制了 shadowsocks 内部状态机的转移，是整个系统最为重要的部分。</p>
<h3 id="_handle_stage_init">_handle_stage_init</h3>
<p><code>_handle_stage_init</code> 函数完成了 SOCKS5 的认证方式协商，如果协商成功，则通过 <code>self._stage = STAGE_ADDR</code> 将状态转移为 <code>STAGE_ADDR</code>。如果协商失败，则直接销毁。这里再次强调一下，因为整个 SOCKS5 协议都是在 <code>sslocal</code> 完成的，所以这个函数只可能被 <code>sslocal</code> 调用。</p>
<h3 id="_handle_stage_addr">_handle_stage_addr</h3>
<p>这个函数乍看下去挺复杂的，不过当我们把 one time auth 和 UDP 部分给剔除，并删掉了一些日志以后，代码就简化了不少：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_handle_stage_addr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">ord</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">CMD_UDP_ASSOCIATE</span><span class="p">:</span>
            <span class="o">...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_UDP_ASSOC</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">CMD_CONNECT</span><span class="p">:</span>
            <span class="c1"># just trim VER CMD RSV</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;unknown command </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="k">return</span>

    <span class="n">header_result</span> <span class="o">=</span> <span class="n">parse_header</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">header_result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;can not parse header&#39;</span><span class="p">)</span>

    <span class="n">addrtype</span><span class="p">,</span> <span class="n">remote_addr</span><span class="p">,</span> <span class="n">remote_port</span><span class="p">,</span> <span class="n">header_length</span> <span class="o">=</span> <span class="n">header_result</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_remote_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="n">remote_addr</span><span class="p">),</span> <span class="n">remote_port</span><span class="p">)</span>
    <span class="c1"># pause reading</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_WRITING</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_DNS</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">:</span>
        <span class="c1"># forward address to remote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_sock</span><span class="p">((</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x05\x00\x00\x01</span><span class="s1">&#39;</span>
                             <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x00\x00\x00\x10\x10</span><span class="s1">&#39;</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="p">)</span>
        <span class="n">data_to_send</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encryptor</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_to_write_to_remote</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_to_send</span><span class="p">)</span>
        <span class="c1"># notice here may go into _handle_dns_resolved directly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dns_resolver</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chosen_server</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dns_resolved</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">header_length</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_to_write_to_remote</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">header_length</span><span class="p">:])</span>
        <span class="c1"># notice here may go into _handle_dns_resolved directly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dns_resolver</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">remote_addr</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dns_resolved</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>对于 <code>sslocal</code> 而言，这段代码实际上就是<a href="/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html#_2">前文</a>中建立连接部分的实现，我们回忆一下 SOCKS5 请求的格式：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>+----+-----+-------+------+----------+----------+
|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  |   1   |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+
</pre></div>
</td></tr></table>

<p>Shadowsocks 只在握手阶段检查了 <code>VER</code> 字段，之后就不管这个字段了。所以 <code>_handle_stage_addr</code> 中只对 <code>CMD</code> 字段进行了检查，也就是第 2 到第 14 行。当执行到第 16 行时，<code>data</code> 的取值符合如下格式：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>+------+----------+----------+------+
| ATYP | DST.ADDR | DST.PORT | DATA |
+------+----------+----------+------+
|  1   |    n     |    2     |  m   |
+------+----------+----------+------+
</pre></div>
</td></tr></table>

<p>其中，<code>ATYP</code>、<code>DST.ADDR</code> 和 <code>DST.PORT</code> 在 shadowsocks 的源码中被称作 <code>header</code>，所以变量 <code>addrtype</code>、<code>remote_addr</code>、<code>remote_port</code> 分别对应了 header 中的字段 <code>ATYP</code>、<code>DST.ADDR</code>、<code>DST.PORT</code>，而 <code>header_length</code> 等于 <code>1 + n + 2</code>。</p>
<p>第 26 行的 <code>if</code> 逻辑块大体上做了两件事：</p>
<ol>
<li>将 <code>data</code> 保存到发送缓冲区 <code>self._data_to_write_to_remote</code>；</li>
<li>调用 <code>self._dns_resolver</code> 进行 DNS 查询，在查询有结果后回调 <code>self._handle_dns_resolved</code>。</li>
</ol>
<p>但是对于 <code>sslocal</code> 和 <code>ssserver</code>，它们在细节上又有所不同：</p>
<ul>
<li>
<p>对于 <code>sslocal</code>：</p>
<ul>
<li>它需要发送 SOCKS5 响应，完成建立连接的过程；</li>
<li>在将数据保存到缓冲区之前，需要先加密（所有发送到 <code>ssserver</code> 的数据都要先加密）；</li>
<li>因为数据要发送给 <code>ssserver</code>，所以 DNS 解析的是 <code>self._chosen_server</code>；</li>
</ul>
</li>
<li>
<p>对于 <code>ssserver</code>：</p>
<ul>
<li>需要从收到的 <code>data</code> 中去除 header 再保存到缓冲区，因为对于 remote（目标服务器）而言，代理对它是透明的；</li>
<li>DNS 解析的是 remote，即 header 中的 <code>DST.ADDR</code>。</li>
</ul>
</li>
</ul>
<p><code>_handle_stage_addr</code> 函数的整个执行过程可以用下图表示：</p>
<p><img alt="handle_stage_addr" src="https://cdn.loggerhead.me/images/handle_stage_addr.png" /></p>
<p>其中，有向箭头表示数据流，虚线表示保存到缓冲区，蓝线表示进行 DNS 查询，橘黄色的框表示数据已经进行了加密，绿色的框表示数据已经进行了解密。在执行完 <code>_handle_stage_addr</code> 以后，状态转移到了 <code>STAGE_DNS</code>，同时对 <code>self._update_stream(STREAM_UP, WAIT_STATUS_WRITING)</code> 的调用，使得当前的 <code>TCPRelayHandler</code> 停止监听任何事件。也就是说，从现在开始，<code>TCPRelayHandler</code> 啥也不管了，直到 DNS 解析完成，调用 <code>self._handle_dns_resolved</code> 再继续干活。</p>
<h3 id="_handle_dns_resolved">_handle_dns_resolved</h3>
<p>我们去掉 <a href="https://en.wikipedia.org/wiki/TCP_Fast_Open">TCP fast open</a> 和日志，只看 <code>_handle_dns_resolved</code> 最基础的形式：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># result -&gt; (hostname, ip)</span>
<span class="k">def</span> <span class="nf">_handle_dns_resolved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="n">ip</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_CONNECTING</span>
    <span class="n">remote_addr</span> <span class="o">=</span> <span class="n">ip</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">:</span>
        <span class="n">remote_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chosen_server</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">remote_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_address</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">remote_sock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_remote_socket</span><span class="p">(</span><span class="n">remote_addr</span><span class="p">,</span>
                                             <span class="n">remote_port</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">remote_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">remote_addr</span><span class="p">,</span> <span class="n">remote_port</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">remote_sock</span><span class="p">,</span>
                   <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_ERR</span> <span class="o">|</span> <span class="n">eventloop</span><span class="o">.</span><span class="n">POLL_OUT</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_server</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_READWRITING</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_DOWN</span><span class="p">,</span> <span class="n">WAIT_STATUS_READING</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>如果有错误发生或者没有 DNS 解析结果，则销毁 <code>TCPRelayHandler</code>；否则，创建一个负责与 remote 通信的套接字，连接到 <code>remote_addr:remote_port</code>，并添加到事件循环中监听 <code>POLL_OUT</code>（可写）。此时，状态转移到 <code>STAGE_CONNECTING</code>。</p>
<h3 id="_handle_stage_connecting">_handle_stage_connecting</h3>
<p>我们去掉 TCP fast open 和 <a href="shadowsocks.org/en/spec/one-time-auth.html">one time auth</a> 相关的代码，将 <code>_handle_stage_connecting</code> 简化为如下逻辑：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_handle_stage_connecting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encryptor</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_data_to_write_to_remote</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>将当前的 <code>data</code> 添加到缓冲区，如果是 <code>sslocal</code>，则加密以后再添加到缓冲区。</p>
<h3 id="_handle_stage_stream">_handle_stage_stream</h3>
<p>去掉 one time auth 相关的代码，将逻辑简化：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_handle_stage_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encryptor</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_sock</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_sock</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>通过 <code>self._remote_sock</code> 套接字无脑将 <code>data</code> 中的数据转发到 remote，只不过 <code>sslocal</code> 在发送前要先加密。</p>
<h2 id="_2">事件与状态</h2>
<p>之前我们略过了几个函数没讲：</p>
<ul>
<li><code>_on_remote_read</code>；</li>
<li><code>_on_remote_write</code> / <code>_on_local_write</code>；</li>
<li><code>_update_steam</code>。</li>
</ul>
<p>它们与 <code>_handle_XXX</code> 的耦合挺高的，单独拿出来会让人莫名其妙，上一张图大家就知道我为什么这么说了……</p>
<p><img alt="ss-event-stage-relationship" src="https://cdn.loggerhead.me/images/ss-event-stage-relationship.svg" /></p>
<ul>
<li>绿色二元组：表示 <code>self._downstream_status</code> 和 <code>self._upstream_status</code> 分别对应的值；</li>
<li>蓝色二元组：表示 <code>self._local_sock</code> 和 <code>self._remote_sock</code> 分别监听的事件，如果为空表示没有监听任何事件；</li>
<li>
<p>实线箭头：表示在下一次事件循环中，如果给定的套接字发生给定的事件，那么会调用哪个函数，比如：</p>
<p><code>handle_stage_init -&gt; Local:IN -&gt; handle_stage_addr</code></p>
<p>表示在调用完 <code>_handle_stage_init</code> 之后的下一次事件循环中，如果 <code>self._local_sock</code> 发生了可读事件，那么 <code>_handle_stage_addr</code> 会被调用；</p>
</li>
<li>
<p>虚线：与实线箭头一样，只不过目标是自身；</p>
</li>
<li>方框内的空心箭头：表示 <code>self._write_to_sock</code> 如果没有全部写成功时，可能发生的变化。</li>
</ul>
<p>上图只是 <code>sslocal</code> 的事件-状态变化图，<code>ssserver</code> 的又略有不同，不过这些都不重要，只要弄明白了每个阶段（stage）分别是干嘛的，对应的监听事件应该怎么变化，就自然而然的明白，能够看懂上图了。</p>
<h3 id="_update_stream">_update_stream</h3>
<p><code>_update_stream</code> 会在 <code>self._XXX_status</code> 发生变化时，更新套接字监听的事件。具体的取值如表所示：</p>
<table>
<thead>
<tr>
<th>status</th>
<th>events</th>
</tr>
</thead>
<tbody>
<tr>
<td>(R, R)</td>
<td>(I, I)</td>
</tr>
<tr>
<td>(R, W)</td>
<td>( , IO)</td>
</tr>
<tr>
<td>(R, RW)</td>
<td>(I, IO)</td>
</tr>
<tr>
<td>(W, R)</td>
<td>(IO, )</td>
</tr>
</tbody>
</table>
<ul>
<li>status 对应的是二元组 <code>(self._downstream_status, self.upstream_status)</code>；</li>
<li>events 对应的是二元组 <code>(self._local_sock, self._remote_sock)</code> 所监听的事件。</li>
</ul>
<p>因为 status 在 shadowsocks 中只可能是以上四种取值，所以这里没有穷举 status 所有的可能。events 中出现的空缺表示只监听 <code>POLL_ERR</code> 事件，比如：<code>( , IO)</code> 表示 <code>self._local_sock</code> 监听 <code>POLL_ERR</code> 事件，<code>self._remote_sock</code> 监听 <code>POLL_IN | POLL_OUT | POLL_ERR</code> 事件。注意，在回调 <code>_handle_dns_resolved</code> 之前，<code>self._remote_sock</code> 的值为 <code>None</code>，<code>_update_stream</code> 不会影响 <code>self._remote_sock</code>。</p>
<p>除去 TCP fast open 相关的逻辑，我们看看所有的 <code>self._update_stream</code> 调用：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_handle_stage_addr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c1"># ( , IO)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_WRITING</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_handle_dns_resolved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
    <span class="c1"># (I, IO)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_READWRITING</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_DOWN</span><span class="p">,</span> <span class="n">WAIT_STATUS_READING</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_on_local_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_to_write_to_local</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># self._remote_sock: POLL_IN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_DOWN</span><span class="p">,</span> <span class="n">WAIT_STATUS_READING</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_on_remote_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_to_write_to_remote</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># self._local_sock: POLL_IN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_READING</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_write_to_sock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">uncomplete</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="p">:</span>
            <span class="c1"># self._local_sock: POLL_OUT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_DOWN</span><span class="p">,</span> <span class="n">WAIT_STATUS_WRITING</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_sock</span><span class="p">:</span>
            <span class="c1"># self._remote_sock: POLL_OUT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_WRITING</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="p">:</span>
            <span class="c1"># self._remote_sock: POLL_IN</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_DOWN</span><span class="p">,</span> <span class="n">WAIT_STATUS_READING</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sock</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_sock</span><span class="p">:</span>
            <span class="c1"># self._local_sock: POLL_IN</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_stream</span><span class="p">(</span><span class="n">STREAM_UP</span><span class="p">,</span> <span class="n">WAIT_STATUS_READING</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<ul>
<li><code>_handle_stage_addr</code>：因为 <code>self._remote_sock</code> 为 <code>None</code>，此时只有 <code>self._local_sock</code> 监听 <code>POLL_ERR</code> 事件。前面说过了，这个函数会通过 <code>self._dns_resolver</code> 解析 remote 对应的 IP，并在回调函数 <code>_handle_dns_resolved</code> 中创建 <code>self._remote_sock</code> 连接至 remote。如果 DNS 解析失败，那么将数据从 <code>self._local_sock</code> 读到缓冲区就毫无意义，白白消耗 CPU；</li>
<li><code>_handle_dns_resolved</code>：此时我们已经得到了 remote 的 IP，并尝试与 remote 建立 TCP 连接。因为此处的 <code>connect</code> 是非阻塞的<sup id="fnref:non-blocking socket"><a class="footnote-ref" href="#fn:non-blocking socket" rel="footnote">2</a></sup>，我们不知道什么时候成功建立了 TCP 连接，所以需要在 <code>self._remote_sock</code> 上注册 <code>POLL_OUT</code> 事件，当事件循环通知我们 <code>self._remote_sock</code> 可写时，说明连接成功。在建立连接的同时，我们将 <code>self._local_sock</code> 注册为可读，将客户端发来的数据缓冲起来（<code>_handle_stage_connecting</code>），降低延迟；</li>
<li><code>_on_local_write</code> / <code>_on_remote_write</code>：这两个函数是十分相似的。它们会将缓冲区的数据发送出去，如果缓冲区空了，则将另一个套接字注册为可读，因为只有它可读才可能重新塞入数据到缓冲区。有一点要注意，<code>_on_remote_write</code> 被调用说明 <code>self._remote_sock</code> 成功建立了连接，此时它会将 <code>self._stage</code> 设置为 <code>STAGE_STREAM</code>；</li>
<li><code>_write_sock</code>：负责将数据通过给定套接字发送出去，并改变对应的监听事件。如果全部发送成功，此时的动作和 <code>_on_XXX_write</code> 一样，将另一个套接字注册为可读；如果没有全部发送成功，则将剩余的数据添加到缓冲区，并将套接字注册为可写。</li>
</ul>
<h3 id="_on_remote_read">_on_remote_read</h3>
<p><code>_on_remote_read</code> 函数比较简单，我们看看简化后的代码：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_on_remote_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remote_sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_update_activity</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_local</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encryptor</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encryptor</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_sock</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_sock</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>从 <code>self._remote_sock</code> 读取数据，并将读到的数据通过 <code>self._local_sock</code> 发送出去。对于 <code>sslocal</code> 而言，收到的数据来自 <code>ssserver</code>，需要解密以后再发送给客户端；对于 <code>ssserver</code> 而言，收到的数据来自目标服务器，需要加密以后再发送给 <code>sslocal</code>。</p>
<h1 id="_3">总结</h1>
<p>理解 shadowsocks 的关键是理解 <code>TCPRelayHandler</code>，其中有些变量，如：<code>self._local_sock</code> 和 <code>self._remote_sock</code>，<code>self._downstream_status</code> 和 <code>self._upstream_status</code> 很让人迷惑，弄清楚它们的区别对于理解 <code>TCPRelayHandler</code> 至关重要。本文对大多数函数进行了分析，但是由于涉及的内容较多，限于篇幅，并未全部覆盖，比如：one time auth、TCP fast open、异步 DNS 以及超时处理都没有提及，可能之后会单独用几篇文章介绍这些内容。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:getaddrinfo">
<p><code>getaddrinfo</code> 在 C 语言中有同名函数，用于进行名字与地址的转换，支持 IPv4 和 IPv6。&#160;<a class="footnote-backref" href="#fnref:getaddrinfo" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:non-blocking socket">
<p><code>_create_remote_socket</code> 中的 <code>remote_sock.setblocking(False)</code> 将套接字设置为了非阻塞的，此时对 <code>connect</code> 的调用要么立刻成功建立 TCP 连接，要么抛出含有 <code>errno.EINPROGRESS</code> 的异常。&#160;<a class="footnote-backref" href="#fnref:non-blocking socket" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      </div>
    </article>
  </section>
    <div id="disqus_thread"></div>
<script>
var disqus_config = function () {
    this.page.identifier = "Shadowsocks 源码分析——TCP 代理";
};

(function() {
    var d = document, s = d.createElement('script');
    s.async = true;
    s.src = "//loggerhead.disqus.com/embed.js";
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
      </div>
    </div>
  </div>
</div>

 <footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-xs-8">
        <p>
          Copyright&nbsp;&copy;&nbsp;2017&nbsp;-&nbsp;loggerhead
        </p>
      </div>
      <div class="col-xs-4">
        <p class="pull-right">
          <a href="#" class="back-to-top">
            <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
            回到顶部
          </a>
        </p>
      </div>
    </div>

    <div class="row hidden-when-phone">
      <div class="col-xs-8">
        <p>
          Powered by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
          &middot;
          <a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备16007488号</a>
        </p>

        <p>
          本站文章均为原创，并遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh_TW" target="_blank">CC BY-SA 4.0 协议</a>
        </p>
      </div><!--/.col-xs-8 -->

      <div class="col-xs-4">
        <p class="pull-right">
          <a href="https://portal.qiniu.com/signup?code=3lg1w78srwitul" target="_blank">
            <img style="height: 45px" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFUAAAA5CAMAAABwHZdJAAAAnFBMVEUAAAAZivoZivoYiPoZifoZifoZifsaivgJkf8ZifoZifoYifoZifsZifoZifoYifsZifkbiv8ZifoZifoYiPsbh/8ZifoYifsZifsYivkZifkYifkZifkZiPoZifgUiP8ZifoZifoZifoZifoYifoYiPoZifsZifoZifsZifoZifoYifsYifsZivoaiPkYifkZifsYiPoZifoZifprs5E2AAAAM3RSTlMAZpc001w6GgSB/L2x9+BLKBL02j8J7eWriYZTUC8hDOjOuO+ln3hgRcnFfHNuWFZHao/W18NFAAACc0lEQVRYw63W6XqiMBgF4MgmCiIKKqBQcK/j1jn3f29jhthUJUhS3j8aeDzgl5WsHNI2wyPAn5ZDI0yJBgxbDe3R90wB+C2GdgB0CTGA1ai10AWA5e3zDCCYtBQ6xI1Fv+UADLu90IJQO9DYjxZC56DCsuHhJujyu7bjzBU7Cjiw1h7UVOepA6AnHZqA4gNqWbZ35OcFSy5z4pYhGrkb4emKBsCVCrW8MmJq82smSgarwhbA2JaaUEz4OHeZHu/Ma/MXLcDE5IEHJqC9r7N6NNLVcHd4vtXHnRMSQlt5o8xRb4y7fPLyL8C5V4N+6A3es7fCt35WuS5wA9wk7zL3mz4Y9hbCWC6oS7TDOMBP/VC0Njz5jOdZZS2tUzTDo7GwXvoKL2aHTfI1v4Z6mqZWOLyc4qgY40WQ1RT/E2rc+gX6L+Q12FCHHmQZVoPFR4OMxmum7qK5dfMNer9EM5EleVZ4b6qlRI6FN8buTn4DzdhvC1QxtMuIKLCnoAbd7ny7doJ8UDbzYLk5Du/zyNc0yVg2yzrsIaPM9/1s9LDrxEAhmbouU5fi2W2wsaowCAYT0R6Q48aUTDVBiQ+3BShdcWhpdaefgdzg4tujRypNQRlEloeSX7NtRNKpDkrHmpuJdKqGklNVHpRM6dQjIOyRHt+rJS3ALMiLGX+gpBTCsRUCikOATMYozUSzGS6RZ4BJRc9LFFJdMFtRxU2F1BiCsbXhxzV5X2D6L7OVXVfZD86oPJfbLpiZrZDq41vUuZj/nXeJB14ZFTPUOymlblGr/6GUaq9Qp0PU6KixJqoscWk1ou4j8SpL6u7J7+hm59miS+r9A2xo/FvmwrFSAAAAAElFTkSuQmCC" />
          </a>
        </p>
      </div>
    </div>
  </div>
</footer>
    <script src="https://loggerhead.me/theme/js/bag.2.0.2.min.js"></script>

<script id="myscripts">
bag = new window.Bag();

bag.require([
    "//cdn.bootcss.com/jquery/2.2.1/jquery.min.js",
    "//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"
]);

function load_css(url, done) {
    var link  = document.createElement('link');
    link.rel  = 'stylesheet';
    link.href = url;
    link.onload = done;
    document.head.appendChild(link);
}

function load_js(url, done) {
    var script = document.createElement('script');
    script.src = url;
    script.onload = done;
    document.body.appendChild(script);
}

function gestureStart() {
    for (i = 0; i < metas.length; i++) {
        if (metas[i].name == "viewport") {
            metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
        }
    }
}

(function screen_suit() {
    var metas = document.getElementsByTagName('meta');
    var ua = navigator.userAgent;
    if (ua.match(/iPhone/i)) {
        for (var i = 0; i < metas.length; i++) {
            if (metas[i].name == "viewport") {
                metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
            }
        }
        document.addEventListener("gesturestart", gestureStart, false);
    }
})();

// See https://gist.github.com/vartan/ab195e5a502a47e0c3e5
(function fix_hover_behavior() {
    if('ontouchstart' in document.documentElement) {
        for(var sheetI = document.styleSheets.length - 1; sheetI >= 0; sheetI--) {
            var sheet = document.styleSheets[sheetI];
            if(sheet.cssRules) {
                for(var ruleI = sheet.cssRules.length - 1; ruleI >= 0; ruleI--) {
                    var rule = sheet.cssRules[ruleI];
                    if(rule.selectorText) {
                        rule.selectorText = rule.selectorText.replace(":hover", ":active");
                    }
                }
            }
        }
    }
})();

(function add_class_to_chinese_em(class_name) {
    var ems = document.getElementsByTagName("em");

    for (var i = 0; i < ems.length; i++) {
        var text = ems[i].textContent;
        // if has chinese char
        if(/.*[\u4e00-\u9fa5]+.*$/.test(text)) {
            ems[i].className += " " + class_name;
        }
    }
})('chinese');

// IE10 viewport hack for Surface/desktop Windows 8 bug
(function fix_ie10_viewport_bug() {
    if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
        bag.require([
            "//maxcdn.bootstrapcdn.com/css/ie10-viewport-bug-workaround.css",
            "//maxcdn.bootstrapcdn.com/js/ie10-viewport-bug-workaround.js"
        ]);
    }
})();

(function load_katex_when_need(class_name) {
    var maths = document.getElementsByClassName(class_name);
    if (maths.length == 0) {
        return;
    }

    bag.require([
        "//cdn.bootcss.com/KaTeX/0.6.0/katex.min.js"
    ]).then(function() {
        for (var i = 0; i < maths.length; i++) {
            var math = maths[i];

            var displayMode = null;
            if (math.tagName == "SPAN") {
                displayMode = false;
            } else if (math.tagName == "DIV") {
                displayMode = true;
            }

            if (displayMode === null) {
                console.log("Cannot render " + math);
            } else {
                try {
                    katex.render(math.textContent, maths[i], { displayMode: displayMode });
                } catch (err) {
                    console.log(err);
                }
            }
        }
    });

    load_css("//cdn.bootcss.com/KaTeX/0.6.0/katex.min.css");
})("math");
</script>

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script>
  bag.require([
    "//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js",
    "//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"
  ]);
  </script>
<![endif]-->
 
</body>
</html>